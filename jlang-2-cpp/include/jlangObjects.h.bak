#ifndef JLANGOBJECTS_H_
#define JLANGOBJECTS_H_
#include <string>
#include <vector>
#include <map>
#include <concepts>

#include "strhash.h"

namespace jlang {

    class NotImplementedException : public std::exception {
        public:
            NotImplementedException(std::string message) : message(message) {}
            const char* what() const noexcept override {
                return message.c_str();
            }
        private:
            std::string message;
    };


#pragma region Enums

    #define ENUM_TOKENTYPE(o) \
        o(KEYWORD)                    /* Keywords are basically all used for statements except for the syscall keyword */\
        o(INTRINSIC) \
        o(IDENTIFIER)                 /* identifiers for variables and functions */\
        o(INT_LITERAL)                /* number literals */\
        o(STRING_LITERAL)             /* string literals */\
        o(OPERATOR)                   /* Things that manipulate values (basically operators but named weird) */\
        o(SYSCALL)                    /* syscalls */\
        /*o(EOE) */                        /* End of expression */\
        o(PAREN_BLOCK_START)          /* Start of parenthesis block */\
        o(PAREN_BLOCK_END)            /* End of parenthesis block */\
        o(ARG_DELIMITER)              /* Argument delimiter */\
        o(TYPE)                       /* Type name */ 

    #define o(n) n, 
    enum class TokenType { ENUM_TOKENTYPE(o) INVALID};
    #undef o

    extern constexpr TokenType get_token_type_by_name(const char *name);
    extern constexpr const char *get_enum_name(TokenType type);
    extern constexpr const char *get_token_type_string(TokenType type);

    #define ENUM_KEYWORD(o) \
        o(IF)          /* if conditional designator */\
        o(WHILE)       /* while conditional designator */\
        o(FUNCTION)    /* function definition designator */\
        o(DEFINE)      /* variable definition designator */\
        o(ALLOCATE)    /* array allocation designator */\
        o(CONSTANT)    /* constant statement designator */\
        o(DO)          /* block open */\
        o(IS)          /* assignment operator and block open */\
        o(AS)          /* type designator */\
        o(TO)          /* unused */\
        o(YIELDS)      /* used to designate return type */\
        o(DONE)        /* block end */\
        o(RETURN)      /* function return */\
        o(IMPORT)      /* file import (preprocessor) */\

    #define o(n) n, 
    enum class Keyword { ENUM_KEYWORD(o) INVALID};
    #undef o

    extern constexpr Keyword get_keyword_by_name(const char *name);
    extern constexpr const char *get_enum_name(Keyword type);

    #define ENUM_OPERATOR(o) \
        o(PLUS) \
        o(MINUS) \
        o(MULTIPLY) \
        o(DIVIDE) \
        o(MODULO) \
        o(GREATER) \
        o(LESS) \
        o(EQUAL) \
        o(NOT_EQUAL) \
        o(GREATER_EQUAL) \
        o(LESS_EQUAL) 

    #define o(n) n, 
    enum class Operator { ENUM_OPERATOR(o) INVALID};
    #undef o

    extern constexpr Operator get_operator_by_name(const char *name);
    extern constexpr const char *get_enum_name(Operator type);



    #define ENUM_INTRINSIC(o) \
        o(SYSCALL0) \
        o(SYSCALL1) \
        o(SYSCALL2) \
        o(SYSCALL3) \
        o(SYSCALL4) \
        o(SYSCALL5) \
        o(PRINT) \
        o(ADDRESS_OF) \
        o(DROP) \
        o(LOAD8) \
        o(LOAD16) \
        o(LOAD32) \
        o(LOAD64) \
        o(STORE8) \
        o(STORE16) \
        o(STORE32) \
        o(STORE64) 

    #define o(n) n, 
    enum class Intrinsic { ENUM_INTRINSIC(o) INVALID};
    #undef o

    extern constexpr Intrinsic get_intrinsic_by_name(const char *name);
    extern constexpr const char *get_enum_name(Intrinsic type);

    #define ENUM_EXPRTYPE(o) \
        o(NONE) \
        o(INTEGER) \
        o(POINTER) 

    #define o(n) n, 
    enum class ExprType { ENUM_EXPRTYPE(o) INVALID};
    #undef o

    extern constexpr ExprType get_expr_type_by_name(const char *name);
    extern constexpr const char *get_enum_name(ExprType type);

#pragma endregion Enums

    typedef struct TokenValue_s{
        union {
            int64_t integer;
            std::string *string;
            Keyword keyword;
            Operator operator_;
            Intrinsic intrinsic;
        } as;
        bool needs_free;

        TokenValue_s(){
            needs_free = false;
        }
        TokenValue_s(int64_t i){
            as.integer = i;
            needs_free = false;
        }
        TokenValue_s(std::string s){
            as.string = new std::string(s);
            needs_free = true;
        }
        template<typename T>
        TokenValue_s(T t) requires std::is_enum_v<T>{
            as = {t};
            needs_free = false;
        }

        ~TokenValue_s(){
            if(needs_free){
                delete as.string;
            }
        }	
    } TokenValue;
    
    std::string get_token_type_value_string(TokenType type, TokenValue value);


    typedef struct Location_s {
        std::string file;
        std::size_t line;
        std::size_t column;

        std::string display() {
            return file + ":" + std::to_string(line) + ":" + std::to_string(column);
        }

        Location_s(){
            file = "";
            line = 0;
            column = 0;
        }
        Location_s(std::string file, std::size_t line, std::size_t column){
            this->file = file;
            this->line = line;
            this->column = column;
        }
    } Location;

    typedef struct Token_s {
        TokenType type;
        std::string text;
        Location location;
        TokenValue value;
        
        std::string display() {
            return location.display() + ": " + get_token_type_string(type) + get_token_type_value_string(type, value) + "; \"" + text + '"';
        }

        Token_s(){
            type = TokenType::INVALID;
            text = "";
            location = Location();
            value = TokenValue();
        }

        Token_s(TokenType type, std::string text, Location location, TokenValue value) {
            this->type = type;
            this->text = text;
            this->location = location;
            this->value = value;
        }
    } Token;

}

#endif